{-|
Module      : Spicy.ONIOM.Layout
Description : Layouting the molecule for ONIOM calculations.
Copyright   : Phillip Seeber, 2020
License     : GPL-3
Maintainer  : phillip.seeber@uni-jena.de
Stability   : experimental
Portability : POSIX, Windows

This module takes care of initial preparation of the 'Molecule' type from a simple structured input
molecule to the ONIOM setup used in subsequent steps.
-}
module Spicy.ONIOM.Layout
  ( oniomNLayout
  )
where
import           Control.Lens            hiding ( Empty )
import qualified Data.IntMap.Strict            as IntMap
import qualified Data.IntSet                   as IntSet
import           Formatting
import           RIO                     hiding ( view
                                                , (^.)
                                                )
import qualified RIO.Map                       as Map
import           RIO.Seq                        ( Seq(..) )
import           Spicy.Class
import           Spicy.Generic
import           Spicy.Logger
import           Spicy.Molecule
import           Spicy.Wrapper.Internal.Generic
import qualified RIO.Text                      as Text
import           System.Path                   as Path

{-|
Prepare the layout for an ONIOM-n calculation, potentially with multi-centre layout at each level.
The top level (real system) is the one obtained from the uppermost theorylayer, not necessarily the
complete system as read from file.
-}
oniomNLayout
  :: (HasInputFile env, HasMolecule env, HasLogFunc env, HasLogFile env) => RIO env Molecule
oniomNLayout = do
  logInfoF "Preparing ONIOM layout of input molecule."

  inputFile        <- view inputFileL
  originalMolecule <- view moleculeL

  -- Step through the theorylayers of the input file and create new layers accordingly. Fail if no
  -- ONIOMn method is specified.
  theoryLayers     <- case inputFile ^? model . _ONIOMn . _1 of
    Just layers -> return layers
    Nothing     -> throwM $ SpicyIndirectionException
      "oniomNLayout"
      "This function can not be used to prepare the molecule layout for calculations,\
      \ that are not ONIOM-n."

  -- Create a calculation context for the top layer, which will be inherited for the next layer.
  template   <- readFileUTF8 $ getFilePath (theoryLayers ^. templateFile)
  permaDir   <- liftIO . makeJDirPathAbsFromCwd $ inputFile ^. permanent
  scratchDir <- liftIO . makeJDirPathAbsFromCwd $ inputFile ^. scratch
  let
    prefixNameTop =
      let saneOniomID = "ONIOMn_Level-0"
          saneDescriptor =
              replaceProblematicChars . Text.unpack . removeWhiteSpace $ theoryLayers ^. name
      in  saneOniomID <> "@" <> saneDescriptor
    calcInput = CalcInput
      { _calcInput_Task        = WTEnergy
      , _calcInput_RestartFile = Nothing
      , _calcInput_Software    = theoryLayers ^. program
      , _calcInput_PrefixName  = prefixNameTop
      , _calcInput_PermaDir    = permaDir
      , _calcInput_ScratchDir  = scratchDir
      , _calcInput_NProcs      = theoryLayers ^. execution . nProcesses
      , _calcInput_NThreads    = theoryLayers ^. execution . nThreads
      , _calcInput_Memory      = theoryLayers ^. execution . memory
      , _calcInput_QMMMSpec    = prepareQMMMSpec (theoryLayers ^. program)
                                                 (theoryLayers ^. charge)
                                                 (theoryLayers ^. mult)
      , _calcInput_Template    = template
      }
    calcContextTop = CalcContext { _calcContext_Input = calcInput, _calcContext_Output = Nothing }

  -- Clean the molecule, that was read from the file from all its sublayers, that might have been
  -- generated by the parser.
  let molCleaned    = originalMolecule & molecule_SubMol .~ IntMap.empty

  -- Create the new sublayer, which is the topmost ONIOM layer (the real system) and use this one as
  -- the new top. Also has first calculation context for the real system added.
  let atomSelection = theoryLayers ^. selection

  logInfoF "  Layer 0 (real system) with atoms:"
  mapM_ (logInfoF . ("    " <>)) . formatPadFoldable 6 int "," . IntSet.toAscList $ atomSelection

  molONIOMTopLayer       <- newSubLayer molCleaned atomSelection Nothing Nothing
  molRealSystemNoContext <- if IntMap.size (molONIOMTopLayer ^. molecule_SubMol) == 1
    then case IntMap.lookupMax $ molONIOMTopLayer ^. molecule_SubMol of
      Just (_, realSystemLayer) -> return realSystemLayer
      Nothing                   -> throwM $ MolLogicException
        "oniomNLayout"
        "During creation of the real system ONIOM-layout something went wrong."
    else throwM $ MolLogicException
      "oniomNLayout"
      "Tried to create the real system layer for ONIOM but the molecule was not clean and\
      \ already contained fragment data in submolecules."
  let molRealSystem =
        molRealSystemNoContext
          &  molecule_CalcContext
          .~ Map.singleton (ONIOMKey Original) calcContextTop

  -- Now step through the deeper ONIOM layers recursively and do the layout for everything.
  let deeperLayers = theoryLayers ^. deeperLayer
  case deeperLayers of
    Empty      -> return molRealSystem
    moreLayers -> fst <$> createNextLayers Empty molRealSystem calcContextTop moreLayers

 where
  createNextLayers
    :: (HasInputFile env, HasLogFunc env, HasLogFile env)
    => MolID                     -- ^ MolID of the molecule layer, which requests to build the
                                 --   deeper layers.
    -> Molecule                  -- ^ Current ONIOM layer, below which no submolecules should exist
                                 --   yet.
    -> CalcContext               --   Calculation context of the current layer, which needs to be
                                 --   inherited for the new layers below.
    -> Seq TheoryLayer           -- ^ The 'TheoryLayer's, from which deeper submolecules will be
                                 --   created.
    -> RIO env (Molecule, MolID) -- ^ The original input molecule with layers added as by
                                 --   theorylayers and the ID of the last oniom layer reached in the
                                 --   recursion. The ID is only used internally as a fold
                                 --   accumulator
  createNextLayers oniomIDAbove molAbove contextAbove theoryLayers = foldl'
    (\accumulator currentTheoLayer -> do

      -- Unwrap the current accumulator. Contains the accumulator of the molecule and the ID, which
      -- are updated synchronously.
      (molAcc, idAcc)            <- accumulator

      -- Get input information.
      inputFile                  <- view inputFileL

      -- Handle the MolIDs for the layers. The ID of the first foldl recursion (ONIOM centre) is
      -- given by the idAcc and subsequent centre IDs will be updated here. Deeper layers are
      -- handled outside the recurion of this fold by updating the accumulator.
      (oniomInitID, oniomLastID) <- case idAcc of
        initID :|> lastID -> return (initID, lastID)
        Empty             -> throwM $ MolLogicException
          "createNextLayers"
          "The inner fold cannot create the real system, only use this for deeper ONIOM layers."
      let oniomIDNextCentre :: MolID
          oniomIDNextCentre = oniomInitID |> (oniomLastID + 1)

      -- For logging and context prepare a human readable identifier of this ONIOM layer.
      let oniomID       = molID2OniomHumandID idAcc

      -- Get the atom selection of this layer.
      let atomSelection = currentTheoLayer ^. selection

      -- Logging for the current layer.
      logInfoF
        $  text2Utf8Builder oniomID
        <> " (MolID "
        <> (displayShow . toList $ idAcc)
        <> ") with atoms:"
      mapM_ (logInfoF . ("    " <>))
        . formatPadFoldable 6 int ","
        . IntSet.toAscList
        $ atomSelection

      -- Prepare stuff for the calculation context.
      template   <- readFileUTF8 $ getFilePath (currentTheoLayer ^. templateFile)
      permaDir   <- liftIO . makeJDirPathAbsFromCwd $ inputFile ^. permanent
      scratchDir <- liftIO . makeJDirPathAbsFromCwd $ inputFile ^. scratch
      let
        prefixNameThis =
          let saneOniomID = Text.unpack . removeWhiteSpace $ oniomID
              saneDescriptor =
                  replaceProblematicChars . Text.unpack . removeWhiteSpace $ currentTheoLayer ^. name
          in  saneOniomID <> "_Original@" <> saneDescriptor
        calcInputThis = CalcInput
          { _calcInput_Task        = WTEnergy
          , _calcInput_RestartFile = Nothing
          , _calcInput_Software    = currentTheoLayer ^. program
          , _calcInput_PrefixName  = prefixNameThis
          , _calcInput_PermaDir    = permaDir
          , _calcInput_ScratchDir  = scratchDir
          , _calcInput_NProcs      = currentTheoLayer ^. execution . nProcesses
          , _calcInput_NThreads    = currentTheoLayer ^. execution . nThreads
          , _calcInput_Memory      = currentTheoLayer ^. execution . memory
          , _calcInput_QMMMSpec    = prepareQMMMSpec (currentTheoLayer ^. program)
                                                     (currentTheoLayer ^. charge)
                                                     (currentTheoLayer ^. mult)
          , _calcInput_Template    = template
          }
        calcContextThis =
          CalcContext { _calcContext_Input = calcInputThis, _calcContext_Output = Nothing }

        prefixNameInherited =
          let saneOniomID = Text.unpack . removeWhiteSpace $ oniomID
              saneDescriptor =
                  replaceProblematicChars
                    .  Text.unpack
                    .  removeWhiteSpace
                    .  Text.pack
                    $  contextAbove
                    ^. calcContext_Input
                    .  calcInput_PrefixName
          in  saneOniomID <> "_Inherited@" <> saneDescriptor
        calcContextInherited =
          contextAbove
            &  calcContext_Input
            .  calcInput_PrefixName
            .~ prefixNameInherited
            &  calcContext_Input
            .  calcInput_PermaDir
            .~ JDirPathAbs (getDirPathAbs permaDir </> Path.relDir "Inherited")
            &  calcContext_Input
            .  calcInput_ScratchDir
            .~ JDirPathAbs (getDirPathAbs scratchDir </> Path.relDir "Inherited")
            &  calcContext_Input
            .  calcInput_QMMMSpec
            .~ prepareQMMMSpec (contextAbove ^. calcContext_Input . calcInput_Software)
                               (currentTheoLayer ^. charge)
                               (currentTheoLayer ^. mult)

      -- Create the new sub layer below the current one.
      molLayerAddedNoContext                 <- newSubLayer molAcc atomSelection Nothing Nothing
      (newHighestSubMolIndex, newSubMolOnly) <-
        case IntMap.lookupMax $ molLayerAddedNoContext ^. molecule_SubMol of
          Just (newIndex, newSubMol) -> return (newIndex, newSubMol)
          Nothing                    -> throwM $ MolLogicException
            "oniomNLayout"
            "A new layer should have been added to the molecule, but none could be found."

      -- Add calculation context information to the new sublayer.
      let subMolCalcContext = Map.fromList
            [ (ONIOMKey Original , calcContextThis)
            , (ONIOMKey Inherited, calcContextInherited)
            ]
          subMolWithContext = newSubMolOnly & molecule_CalcContext .~ subMolCalcContext

      -- Recursively also step through all deeper theory layers of this one, creating the even
      -- deeper layers here.
      let deeperLayersOfThis = currentTheoLayer ^. deeperLayer
      finalNewSubMol <- case deeperLayersOfThis of
        -- If no deeper layers are found, we are done here with creation of the deeper layers and
        -- the submolecule can be used.
        Empty      -> return subMolWithContext
        -- If deeper layers can be found, use this function recursively to also create thus.
        moreLayers -> fst <$> createNextLayers idAcc subMolWithContext calcContextThis moreLayers

      -- Now that the context of this sublayer and all its sublayers below have been prepared,
      -- return the layer that was given as input with the new sublayer created. Use it as the new
      -- accumulator.
      let molUpdated =
            molAcc & molecule_SubMol %~ IntMap.insert newHighestSubMolIndex finalNewSubMol
      return (molUpdated, oniomIDNextCentre)
    )
    (return (molAbove, oniomIDAbove |> 0))
    theoryLayers
